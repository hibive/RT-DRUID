OIL_VERSION = "2.4";

IMPLEMENTATION ee {
    OS {
        ENUM [
            AVR_5 {
                STRING ID = "default_cpu";
                STRING APP_SRC[];
                
                BOOLEAN [
                    TRUE {
						BOOLEAN [
							TRUE {
								UINT32 SYS_SIZE;
							},
							FALSE
						] IRQ_STACK;
						ENUM [
							SHARED,
							PRIVATE {
								UINT32 SYS_SIZE;
							}
						] DUMMY_STACK;
                    },
                FALSE
                ] MULTI_STACK = FALSE;
                
                UINT32 STACK_BOTTOM;

                UINT32 SYS_SIZE;    // available space for all user stacks
                UINT32 SHARED_MIN_SYS_SIZE;    // size of shared stack
                
                ENUM [STOP, DIV1, DIV8, DIV32, DIV64, DIV256, DIV1024] TIMER0 = STOP;
                ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER1 = STOP;
                ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER2 = STOP;
                ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER3 = STOP;

                // Interrupt Handlers
                STRING HANDLER_IRQ0;	// external interrupt request 0
                STRING HANDLER_IRQ1;	// external interrupt request 1
                STRING HANDLER_IRQ2;	// external interrupt request 2
                STRING HANDLER_IRQ3;	// external interrupt request 3
                STRING HANDLER_IRQ4;	// external interrupt request 4
                STRING HANDLER_IRQ5;	// external interrupt request 5
                STRING HANDLER_IRQ6;	// external interrupt request 6
                STRING HANDLER_IRQ7;	// external interrupt request 7
                
                STRING HANDLER_T0_MATCH;	// Timer/Counter 0 Compare Match
                STRING HANDLER_T0_OVERFLW;	// Timer/Counter 0 Overflow
                STRING HANDLER_T1_EVENT;	// Timer/Counter 1 Capture Event
                STRING HANDLER_T1_MATCH_A;	// Timer/Counter 1 Compare Match A
                STRING HANDLER_T1_MATCH_B;	// Timer/Counter 1 Compare Match B
                STRING HANDLER_T1_MATCH_C;	// Timer/Counter 1 Compare Match C
                STRING HANDLER_T1_OVERFLW;	// Timer/Counter 1 Overflow
                STRING HANDLER_T2_MATCH;	// Timer/Counter 2 Compare Match
                STRING HANDLER_T2_OVERFLW;	// Timer/Counter 2 Overflow
                STRING HANDLER_T3_EVENT;	// Timer/Counter 3 Capture Event
                STRING HANDLER_T3_MATCH_A;	// Timer/Counter 3 Compare Match A
                STRING HANDLER_T3_MATCH_B;	// Timer/Counter 3 Compare Match B
                STRING HANDLER_T3_MATCH_C;	// Timer/Counter 3 Compare Match C
                STRING HANDLER_T3_OVERFLW;	// Timer/Counter 3 Overflow

                STRING HANDLER_SPI; 	// SPI Serial Transfer Complete
                
                STRING HANDLER_US0_RX;  	// USART0 Rx complete
                STRING HANDLER_US0_EMPTY;	// USART0 Data Register Empty
                STRING HANDLER_US0_TX;  	// Usart0 Tx complete
                
                STRING HANDLER_US1_RX;  	// USART1 Rx complete
                STRING HANDLER_US1_EMPTY;	// USART1 Data Register Empty
                STRING HANDLER_US1_TX;  	// Usart1 Tx complete
                
                STRING HANDLER_ADC; 	// ADC Conversion Complete
                STRING HANDLER_EEPROM;	// EEPROM Ready
                STRING HANDLER_ANALOG_COMP;	// Analog Comparator
                STRING HANDLER_2WSI;	// Two-wire serial Interface
                STRING HANDLER_SPM_READY;	// Store program Memory Ready
                
                
                ENUM [
                    HANDLER_IRQ0 {	// external interrupt request 0
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ1 {	// external interrupt request 1
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ2 {	// external interrupt request 2
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ3 {	// external interrupt request 3
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ4 {	// external interrupt request 4
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ5 {	// external interrupt request 5
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ6 {	// external interrupt request 6
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_IRQ7 {	// external interrupt request 7
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                
	                }, HANDLER_T0_MATCH {	// Timer/Counter 0 Compare Match
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T0_OVERFLW {	// Timer/Counter 0 Overflow
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T1_EVENT {	// Timer/Counter 1 Capture Event
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T1_MATCH_A {	// Timer/Counter 1 Compare Match A
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T1_MATCH_B {	// Timer/Counter 1 Compare Match B
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T1_MATCH_C {	// Timer/Counter 1 Compare Match C
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T1_OVERFLW {	// Timer/Counter 1 Overflow
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T2_MATCH {	// Timer/Counter 2 Compare Match
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T2_OVERFLW {	// Timer/Counter 2 Overflow
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T3_EVENT {	// Timer/Counter 3 Capture Event
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T3_MATCH_A {	// Timer/Counter 3 Compare Match A
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T3_MATCH_B {	// Timer/Counter 3 Compare Match B
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T3_MATCH_C {	// Timer/Counter 3 Compare Match C
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_T3_OVERFLW {	// Timer/Counter 3 Overflow
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	
	                }, HANDLER_SPI { 	// SPI Serial Transfer Complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                
	                }, HANDLER_US0_RX {  	// USART0 Rx complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_US0_EMPTY {	// USART0 Data Register Empty
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_US0_TX {  	// Usart0 Tx complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                
	                }, HANDLER_US1_RX {  	// USART1 Rx complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_US1_EMPTY {	// USART1 Data Register Empty
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_US1_TX {  	// Usart1 Tx complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                
	                }, HANDLER_ADC { 	// ADC Conversion Complete
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_EEPROM {	// EEPROM Ready
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_ANALOG_COMP {	// Analog Comparator
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_2WSI {	// Two-wire serial Interface
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }, HANDLER_SPM_READY {	// Store program Memory Ready
                    	STRING FUNCTION;
                    	INT32[1,2] TYPE = 1;
	                }
	                
                ] HANDLER[];
            },
            
            AVR8 {
                STRING ID = "default_cpu";
                STRING APP_SRC[];
                
                BOOLEAN [
                    TRUE {
						BOOLEAN [
							TRUE {
								UINT32 SYS_SIZE;
							},
							FALSE
						] IRQ_STACK;
                    },
                FALSE
                ] MULTI_STACK = FALSE;

                UINT32 SYS_STACK_SIZE;
            }
            

        ] CPU_DATA[];

		ENUM [
			ATMEGA_STK50X,
			XBOW_MIB5X0 {
				BOOLEAN USELEDS = FALSE;
			},
			ATMEL_STK50X {
				BOOLEAN USELEDS = FALSE;
				BOOLEAN USEBUTTON = FALSE;
			},
			ATMEL_STK600 {
				BOOLEAN USELEDS = TRUE;
				ENUM [A, B, C, D, E, F, G, H, J, K, L, M, N, P, Q] LEDPORT = A;
			},
			ARDUINO_UNO {
				BOOLEAN USELEDS = TRUE;
			}
		] BOARD_DATA = NO_BOARD;
		
		ENUM [
			XMEGA {
			
				ENUM [
					XMEGA_16d4
				] MODEL = XMEGA_16d4;

				BOOLEAN AVR_PGMSPACE = FALSE;

				/* Timer Counter Type 1 */
				BOOLEAN USE_TC_HW = FALSE;

				// MCU DRIVER 
				BOOLEAN  [
					TRUE {
						ENUM [STANDARD, EXTENDED] MCU_STATUS = STANDARD;
						BOOLEAN MCU_DEINIT_API = FALSE;
						BOOLEAN MCU_INITCLOCK_API = FALSE;
						BOOLEAN MCU_DEINITCLOCK_API = FALSE;
						BOOLEAN MCU_GETCLOCKSTATUS_API = FALSE;
						BOOLEAN MCU_DISTRIBUTECLOCK_API = FALSE;
						BOOLEAN MCU_SETMODE_API = FALSE;
						BOOLEAN MCU_GETRESETREASON_API = FALSE;
						BOOLEAN MCU_PERFORMRESET_API = FALSE;
					}, FALSE
				] ENABLE_MCU_DRIVER = FALSE;
		
				/* POWER REDUCTION */
				BOOLEAN  [ 
					TRUE {
						BOOLEAN PULL_UP = FALSE;
						BOOLEAN PORT_OUT = FALSE;
						BOOLEAN JTAG = FALSE;
					}, FALSE
				] ENABLE_MCU_POWER_REDUCTION = FALSE;
		
				/* E2P DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STANDARD, EXTENDED] E2P_STATUS = STANDARD;
						BOOLEAN E2P_INTERRUPT = FALSE;
						BOOLEAN E2P_SYNCHRONOUS = FALSE;
						BOOLEAN E2P_GETSTATUS_API = FALSE;
						BOOLEAN E2P_DEINIT_API = FALSE;
						BOOLEAN E2P_READ_API = FALSE;
						BOOLEAN E2P_WRITE_API = FALSE;
						BOOLEAN E2P_ERASE_API = FALSE;
						BOOLEAN E2P_COMPARE_API = FALSE;
						BOOLEAN E2P_CANCEL_API = FALSE;
					}, FALSE
				] ENABLE_E2P_DRIVER = FALSE;

				/* GPIO DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STANDARD, EXTENDED] GPIO_STATUS = STANDARD;
						BOOLEAN GPIO_DEINIT_API = FALSE;
						BOOLEAN GPIO_READCHANNEL_API = FALSE;
						BOOLEAN GPIO_READCHANNEL_NTS = FALSE;
						BOOLEAN GPIO_WRITECHANNEL_API = FALSE;
						BOOLEAN GPIO_WRITECHANNEL_NTS = FALSE;
						BOOLEAN GPIO_FLIPCHANNEL_API = FALSE;
						BOOLEAN GPIO_FLIPCHANNEL_NTS = FALSE;
						BOOLEAN GPIO_ENABLENOTIF_API = FALSE;
						BOOLEAN GPIO_DISABLENOTIF_API = FALSE;
					}, FALSE
				] ENABLE_GPIO_DRIVER = FALSE;
			
				/* GPT DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_C_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_D_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_E_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_F_0 = STOP;
				
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_C_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_D_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_E_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] GPT_CHANNEL_F_1 = STOP : "Requires USE_TC_HW = TRUE.";
				
						ENUM [STANDARD, EXTENDED] GPT_STATUS = STANDARD;
						BOOLEAN GPT_ONESHOT = FALSE;
						BOOLEAN GPT_GETSTATUS_API = FALSE;
						BOOLEAN GPT_DEINIT_API = FALSE;
						BOOLEAN GPT_ENABLENOTIF_API = FALSE;
						BOOLEAN GPT_DISABLENOTIF_API = FALSE;
						BOOLEAN GPT_STOPTIMER_API = FALSE;
						BOOLEAN GPT_GETTIMEELAPSED_API = FALSE;
						BOOLEAN GPT_GETTIMEREMAINING_API = FALSE;
					}, FALSE
				] ENABLE_GPT_DRIVER = FALSE;
			
				/* PWM DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_C_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_D_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_E_0 = STOP;
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_F_0 = STOP;
				
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_C_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_D_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_E_1 = STOP : "Requires USE_TC_HW = TRUE.";
						ENUM [STOP, DIV1, DIV2, DIV4, DIV8, DIV64, DIV256, DIV1024] PWM_CHANNEL_F_1 = STOP : "Requires USE_TC_HW = TRUE.";
				
						ENUM [NONE, A, B, C, D] PWM_C_0_CC = NONE;
						ENUM [NONE, A, B, C, D] PWM_D_0_CC = NONE;
						ENUM [NONE, A, B, C, D] PWM_E_0_CC = NONE;
						ENUM [NONE, A, B, C, D] PWM_F_0_CC = NONE;
				
						ENUM [NONE, A, B] PWM_C_1_CC = NONE : "Requires USE_TC_HW = TRUE.";
						ENUM [NONE, A, B] PWM_D_1_CC = NONE : "Requires USE_TC_HW = TRUE.";
						ENUM [NONE, A, B] PWM_E_1_CC = NONE : "Requires USE_TC_HW = TRUE.";
						ENUM [NONE, A, B] PWM_F_1_CC = NONE : "Requires USE_TC_HW = TRUE.";

						ENUM [STANDARD, EXTENDED] PWM_STATUS = STANDARD;
						BOOLEAN PWM_GETSTATUS_API = FALSE;
						BOOLEAN PWM_DEINIT_API = FALSE;
						BOOLEAN PWM_ENABLENOTIF_API = FALSE;
						BOOLEAN PWM_DISABLENOTIF_API = FALSE;
						BOOLEAN PWM_SETDUTYCYCLE_API = FALSE;
						BOOLEAN PWM_GETOUTPUTSTATE_API = FALSE;
					}, FALSE
				] ENABLE_PWM_DRIVER = FALSE;


				/* RTC DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STOP, DIV1, DIV2, DIV8, DIV16, DIV64, DIV256, DIV1024] RTC_CHANNEL_0 = STOP;
	
						ENUM [STANDARD, EXTENDED] RTC_STATUS = STANDARD;
						BOOLEAN RTC_GETSTATUS_API = FALSE;
						BOOLEAN RTC_DEINIT_API = FALSE;
						BOOLEAN RTC_ENABLENOTIF_API = FALSE;
						BOOLEAN RTC_DISABLENOTIF_API = FALSE;
						BOOLEAN RTC_STOP_API = FALSE;
						BOOLEAN RTC_GETCOUNTER_API = FALSE;
						BOOLEAN RTC_SETCOUNTER_API = FALSE;
					}, FALSE
				] ENABLE_RTC_DRIVER = FALSE;
			
				/* SCI DRIVER */
				BOOLEAN  [
					TRUE {
						ENUM [STANDARD, EXTENDED] SCI_STATUS = STANDARD;
						BOOLEAN SCI_BAUDRATE_TABLE = FALSE;
						BOOLEAN SCI_GETSTATUS_API = FALSE;
						BOOLEAN SCI_DEINIT_API = FALSE;
						BOOLEAN SCI_WRITETXDATA_API = FALSE;
						BOOLEAN SCI_WRITETXDATA__NTS = FALSE;
						BOOLEAN SCI_DISABLETX_API = FALSE;
						BOOLEAN SCI_ENABLETX_API = FALSE;
						BOOLEAN SCI_READRXDATA_API = FALSE;
						BOOLEAN SCI_READRXDATA_NTS = FALSE;
						BOOLEAN SCI_DISABLERX_API = FALSE;
						BOOLEAN SCI_ENABLERX_API = FALSE;
						BOOLEAN SCI_ENABLENOTIF_API = FALSE;
						BOOLEAN SCI_DISABLENOTIF_API = FALSE;
					}, FALSE
				] ENABLE_SCI_DRIVER = FALSE;
			},
			MEGA {
			
				ENUM [
					MEGA_328p
				] MODEL = MEGA_328p;

				BOOLEAN USEIC = FALSE;
				BOOLEAN USEUART = FALSE;
				BOOLEAN USESPI = FALSE;

				ENUM [STOP, DIV1, DIV8, DIV32, DIV64, DIV256, DIV1024] TIMER0 = STOP;
				ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER1 = STOP;
				ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER2 = STOP;
				ENUM [STOP, DIV1, DIV8,        DIV64, DIV256, DIV1024] TIMER3 = STOP;
			}
		] MCU_DATA;
    };
};

