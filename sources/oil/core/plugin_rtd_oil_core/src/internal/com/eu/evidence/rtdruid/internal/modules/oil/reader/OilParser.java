/* Generated By:JavaCC: Do not edit this line. OilParser.java */
package com.eu.evidence.rtdruid.internal.modules.oil.reader;

import java.io.InputStream;
import java.util.LinkedList;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.eu.evidence.rtdruid.internal.modules.oil.keywords.IOilXMLLabels;


/** Parse an oil file and convert it into a XML file.
* @author Nicola Serreli
*/
public class OilParser extends MergeHelper implements OilParserConstants {

        protected final static String LOCATION = "Location_inside_the_oil";

        protected final static String[] ATTR_ATT_LIST = {
                        IOilXMLLabels.ATTR_AUTO,
                        IOilXMLLabels.ATTR_DEFAULT_VALUE,
                        IOilXMLLabels.ATTR_MULTIPLE_VALUES,
                        IOilXMLLabels.ATTR_TYPE,
                        IOilXMLLabels.ATTR_WITH_AUTO
                };
        protected final static String[] ATTR_REF_LIST = {
                        IOilXMLLabels.ATTR_MULTIPLE_VALUES,
                        IOilXMLLabels.ATTR_OBJ_TYPE,
                };
        protected final static String[] ATTR_VAR_LIST = {
                        IOilXMLLabels.ATTR_DEFAULT_VALUE,
                        IOilXMLLabels.ATTR_MULTIPLE_VALUES,
                        IOilXMLLabels.ATTR_WITH_AUTO
                };
        protected final static String[] ATTR_RANGE_LIST = {
                        IOilXMLLabels.ATTR_MAX,
                        IOilXMLLabels.ATTR_MIN
                };
//	protected String defaultImplementationFile = null;
        protected boolean enableApplicationSection = true;

        /*public static void main(String args[]) throws ParseException {
		OilParser parser = new OilParser(System.in);

		OilInfo risp = parser.start();
		System.out.println("--- FINE ---");
		System.out.println(risp.getImpl().getDocumentElement().toString() );
		System.out.println(risp.getAppl().getDocumentElement().toString() );
		
	}*/

//	public void setDefaultImplementationFile(String fileName) {
//		defaultImplementationFile = fileName;
//	}
        public void setEnableApplicationSection(boolean value) {
                enableApplicationSection = value;
        }

        /**
	 * Search a child with specified properties. If itsn't found, make a new one. 
	 */
        protected Element makeElement(Node parent, String elemName, String attrName, String attrValue) {
                NodeList children = parent.getChildNodes();

                for (int i=0; i<children.getLength(); i++) {
                        Node n = children.item(i);

                        if (n instanceof Element) {
                                Element child =(Element) n;

                                // check properties
                                boolean ok = checkStrings(elemName,child.getNodeName());
                                if (ok && attrName != null) {
                                        ok = checkStrings(attrValue, child.getAttribute(attrName));
                                }
                                if (ok) { // found
                                        return child;
                                }
                        }
                }

                Element child = parent.getOwnerDocument().createElement(elemName);
                if (attrName != null) {
                        child.setAttribute(attrName, attrValue);
                }

                parent.appendChild(child);

                return child;
        }
        /**
	 * Search a child with specified properties. If itsn't found, make a new one. 
	 */
        protected Element makeElement(Node parent, String elemName, String[] attrName, String[] attrValue) {
                NodeList children = parent.getChildNodes();

                for (int i=0; i<children.getLength(); i++) {
                        Node n = children.item(i);

                        if (n instanceof Element) {
                                Element child =(Element) n;

                                // check properties
                                boolean ok = checkStrings(elemName,child.getNodeName());
                                for (int att=0; att<attrName.length && ok; att++) {

                                        ok = checkStrings(attrValue[att], child.getAttribute(attrName[att]));
                                }

                                if (ok) { // found
                                        return child;
                                }
                        }
                }

                Element child = parent.getOwnerDocument().createElement(elemName);
                for (int att=0; att<attrName.length; att++) {
                        child.setAttribute(attrName[att], attrValue[att]);
                }

                parent.appendChild(child);

                return child;
        }

        /**
	 * Search an attribute and check the value. If the attribute doesn't exist, set it. 
	 *
	 * @throws ParseException if the attribute is already setted but with a different value
	 */
        protected void setAttribute(Element elem, String attrName, String attrValue, Token token)
                         throws ParseException {

                if (!elem.hasAttribute(attrName)) {
                        if (attrValue != null) {
                                elem.setAttribute(attrName, attrValue);
                        }

                } else if (!checkStrings(elem.getAttribute(attrName), attrValue)) {
                        throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                        + "property = " + attrName + "; old value = " + elem.getAttribute(attrName) + "; new value = " + attrValue + "\u005cn"
                        + "(row =" +token.beginLine + ", col = "+token.beginColumn+")");
                }
        }

// ----------- START ----------------
  final public OilInfo start() throws ParseException {
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        Document impl, appl;
        String nome = null;

        try {
                impl = docFactory.newDocumentBuilder().newDocument();
                appl = docFactory.newDocumentBuilder().newDocument();
        } catch (ParserConfigurationException e) {
                throw new IllegalStateException("OilParser: exception during creation of a new Document:\u005cn\u005ct"
                        + e.getMessage());
        }

        Element root1 = impl.createElement(IOilXMLLabels.ELEM_IMPLEMENTATION);
        impl.appendChild( root1 );

        Element root2 = appl.createElement(IOilXMLLabels.ELEM_APPLICATION);
        appl.appendChild( root2 );
    switch (jj_nt.kind) {
    case OIL_VERSION:
      OIL_version();
      // nome identifies this Builder and will be the first "cpu" type
                      nome = implementation_definition(root1);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
           if (nome == null) {
/*		// use the default Implementation File
		OilInfo childInfo = null;
		InputStream input = this.getClass().getResourceAsStream(defaultImplementationFile);
		OilParser child = new OilParser(input);
		child.setEnableApplicationSection(false);
		try {
			childInfo = child.start();
		} catch (ParseException e) {
			//e.printStackTrace();
		    throw new RuntimeException(
			    "OilReader: exception during the parse.",
                            e);
		} catch (RuntimeException e) {
			//e.printStackTrace();
		    throw new RuntimeException(
			    "OilReader: exception during the parse.",
				    e);
		}
		nome = childInfo.name;
	        impl = childInfo.impl;	
	    */
/*	  } else {
		// Drops the information about version
		OIL_version()
		// nome identifies this Builder and will be the first "cpu" type
		nome = implementation_definition(root1)
*/        }
    switch (jj_nt.kind) {
    case CPU:
      application_definition(appl, root2);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(0);
                OilInfo oi = new OilInfo( nome, impl, appl);
                {if (true) return oi;}
    throw new Error("Missing return statement in function");
  }

  final public String getDescription() throws ParseException {
        String s;
    jj_consume_token(40);
    s = getString();
                // drop \"
                {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String getString() throws ParseException {
        Token t;
    t = jj_consume_token(String);
                // drop \"
                {if (true) return t.image.substring(1,t.image.length()-1);}
    throw new Error("Missing return statement in function");
  }

// ----------- Syntax of OIL ----------------
  final public void OIL_version() throws ParseException {
    jj_consume_token(OIL_VERSION);
    jj_consume_token(41);
    getString();
    switch (jj_nt.kind) {
    case 40:
      getDescription();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

// ----------- Implementation Definition ----------------
  final public String implementation_definition(Node elem) throws ParseException {
        Token t1;
        String nome;
    jj_consume_token(IMPLEMENTATION);
    // get name of this structure
            t1 = jj_consume_token(name);
                //System.err.println("nome = " + t1.image );
                nome = t1.image;
                ((Element) elem).setAttribute(IOilXMLLabels.ATTR_NAME, nome);
    jj_consume_token(43);
    label_1:
    while (true) {
      implementation_spec(elem);
      switch (jj_nt.kind) {
      case object:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(44);
    switch (jj_nt.kind) {
    case 40:
      addDescription((Element) elem);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(42);
                {if (true) return nome;}
    throw new Error("Missing return statement in function");
  }

  final public void implementation_spec(Node elem) throws ParseException {
        Token t1;
        Element nContainer = null;
    // get name of this container
            t1 = jj_consume_token(object);
                nContainer = makeElement(elem, IOilXMLLabels.ELEM_FIRST_LEVEL_OBJ, IOilXMLLabels.ATTR_OBJ_TYPE, t1.image);
    jj_consume_token(43);
    label_2:
    while (true) {
      switch (jj_nt.kind) {
      case UINT32:
      case INT32:
      case UINT64:
      case INT64:
      case FLOAT:
      case ENUM:
      case STRING:
      case BOOLEAN:
      case object_ref_type:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      implementation_def(nContainer, false);
    }
    jj_consume_token(44);
    switch (jj_nt.kind) {
    case 40:
      addDescription(nContainer);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

  final public void implementation_def(Node elem, boolean nested) throws ParseException {
    switch (jj_nt.kind) {
    case UINT32:
    case INT32:
    case UINT64:
    case INT64:
    case FLOAT:
    case ENUM:
    case STRING:
    case BOOLEAN:
      impl_attr_def(elem, nested);
      break;
    case object_ref_type:
      impl_ref_def(elem, nested);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void impl_attr_def(Node elem, boolean nested) throws ParseException {
        Token nameToken;
        boolean wAuto = false;
        boolean multiValues = false;
        // range or list of values -> string[0] = "range" or "list"
        String[] values = null;
        // "default value" = (0), "AUTO" = (1) -> only one != null 
        // dValue = null means "no_default"
        String[] dValue = null;
        // list of enumerator
        Element[] enumList = null;

        // used after to make the xml Document
        Element nodo;
        int tipo;       // tells the type of this node
        String tipoTxt;
        String descr = null;
    switch (jj_nt.kind) {
    case UINT32:
      jj_consume_token(UINT32);
                   tipo = UINT32; tipoTxt ="uint32";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      values = number_range();
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                            multiValues = true;
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      dValue = default_number();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case INT32:
      jj_consume_token(INT32);
                  tipo = INT32; tipoTxt ="int32";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      values = number_range();
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                            multiValues = true;
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      dValue = default_number();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case UINT64:
      jj_consume_token(UINT64);
                   tipo = UINT64; tipoTxt ="uint64";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      values = number_range();
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                            multiValues = true;
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      dValue = default_number();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case INT64:
      jj_consume_token(INT64);
                  tipo = INT64; tipoTxt ="int64";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                     wAuto = true;
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      values = number_range();
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                           multiValues = true;
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      dValue = default_number();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
                  tipo = FLOAT; tipoTxt ="float";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      values = float_range();
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                           multiValues = true;
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      dValue = default_float();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case ENUM:
      jj_consume_token(ENUM);
                 tipo = ENUM; tipoTxt = "enum";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      enumList = enumeration(elem.getOwnerDocument());
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                           multiValues = true;
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      dValue = default_name();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case STRING:
      jj_consume_token(STRING);
                   tipo = STRING; tipoTxt = "String";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                           multiValues = true;
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      dValue = default_string();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
                    tipo = BOOLEAN; tipoTxt = "boolean";
      switch (jj_nt.kind) {
      case auto_specifier:
        jj_consume_token(auto_specifier);
                                    wAuto = true;
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      enumList = bool_values(elem.getOwnerDocument());
      switch (jj_nt.kind) {
      case name:
        nameToken = jj_consume_token(name);
        break;
      case object:
        nameToken = jj_consume_token(object);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case 45:
        jj_consume_token(45);
        jj_consume_token(46);
                           multiValues = true;
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      dValue = default_bool();
      switch (jj_nt.kind) {
      case 40:
        descr = getDescription();
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      jj_consume_token(42);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         // Look over data

                if (searchElement(elem, IOilXMLLabels.ELEM_REFERENCE, IOilXMLLabels.ATTR_NAME, nameToken.image) != null) {
                        {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                        + nameToken.image + " declared as REFERENCE and as " + tipoTxt + "\u005cn"
                        + "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")");}
                }

                //System.err.println( tipo + " " + tipoTxt);
                // leaf
                if ( tipo == UINT32 ||
                     tipo ==  INT32 ||
                     tipo == UINT64 ||
                     tipo ==  INT64 ||
                     tipo ==  FLOAT ||
                     tipo == STRING ) {
                        if (searchElement(elem, IOilXMLLabels.ELEM_VARIANT, IOilXMLLabels.ATTR_NAME, nameToken.image) != null) {
                                {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                                + nameToken.image + " declared as VARIANT and as " + tipoTxt + "\u005cn"
                                + "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")");}
                        }
                        nodo = makeElement(elem, IOilXMLLabels.ELEM_ATTRIBUTE, IOilXMLLabels.ATTR_NAME, nameToken.image);
                }
                else {  // ENUM , BOOLEAN

                        if (searchElement(elem, IOilXMLLabels.ELEM_ATTRIBUTE, IOilXMLLabels.ATTR_NAME, nameToken.image) != null) {
                                {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                                + nameToken.image + " declared as ATTRIBUTE and as " + tipoTxt + "\u005cn"
                                + "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")");}
                        }
                        nodo = makeElement(elem, IOilXMLLabels.ELEM_VARIANT, IOilXMLLabels.ATTR_NAME, nameToken.image);
                }

                tipoTxt = tipoTxt.toUpperCase();
                setAttribute(nodo, IOilXMLLabels.ATTR_TYPE, tipoTxt, nameToken);

                if (nested) {
                        setAttribute(nodo, LOCATION, "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")", nameToken);
                }


                // with auto option
                if (wAuto) {
                        setAttribute(nodo, IOilXMLLabels.ATTR_WITH_AUTO, "true", nameToken);
                }

                // default Value / auto Value
                if (dValue != null) {
                        if (dValue[0] != null) {
                                setAttribute(nodo, IOilXMLLabels.ATTR_DEFAULT_VALUE, dValue[0], nameToken);
                        } else if (dValue[1] != null) {
                                setAttribute(nodo, IOilXMLLabels.ATTR_AUTO, "true", nameToken);
                        }
                }

                // multiple Values option
                if (multiValues) {
                        setAttribute(nodo, IOilXMLLabels.ATTR_MULTIPLE_VALUES, "true", nameToken);
                }

                // range or list of values
                if (values != null) {
                        // range
                        if (values[0].equals("range") ) {
                                if (searchElement(nodo, IOilXMLLabels.ELEM_VALUE, null, null) != null) {
                                        {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                                        + "RANGE-VALUE of " + nameToken.image + "\u005cn"
                                        + "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")");}
                                }

                                Element el = makeElement(elem, IOilXMLLabels.ELEM_RANGE, (String) null, (String) null);

                                setAttribute(el, IOilXMLLabels.ATTR_MIN, values[1], nameToken);
                                setAttribute(el, IOilXMLLabels.ATTR_MIN, values[2], nameToken);
                        }

                        // list of values
                        else if (values[0].equals("value") ) {
                                if (searchElement(nodo, IOilXMLLabels.ELEM_RANGE, null, null) != null) {
                                        {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                                        + "RANGE-VALUE of " + nameToken.image + "\u005cn"
                                        + "(row =" +nameToken.beginLine + ", col = "+nameToken.beginColumn+")");}
                                }

                                for (int i=1; i< values.length; i++) {
                                        makeElement(elem, IOilXMLLabels.ELEM_VALUE, IOilXMLLabels.ATTR_VALUE, values[1]);
                                }
                        }
                }

                // enum list
                if ( enumList != null) {
                        for (int i=0; i< enumList.length; i++) {

                                if (nested) {
                                        nodo.appendChild( enumList[i] );
                                } else {
                                        mergeElement(nodo, enumList[i]);
                                }
                        }
                }

                // description
                if (descr != null) {
                        Element nDescr = nodo.getOwnerDocument().createElement(IOilXMLLabels.ELEM_DESCRIPTION);
                        nDescr.appendChild( nodo.getOwnerDocument().createTextNode( descr ) );
                        nodo.appendChild(nDescr);
                }
  }

  final public String[] number_range() throws ParseException {
        LinkedList valori = null;
        Token t;
    switch (jj_nt.kind) {
    case 45:
      if (jj_2_1(4)) {
        jj_consume_token(45);
        t = jj_consume_token(number);
                        valori = new LinkedList();
                        valori.addLast("range");
                        valori.addLast(t.image);
        jj_consume_token(47);
        t = jj_consume_token(number);
                        valori.addLast(t.image);
        jj_consume_token(46);
      } else {
        switch (jj_nt.kind) {
        case 45:
          jj_consume_token(45);
          t = jj_consume_token(number);
                        valori = new LinkedList();
                        valori.addLast("list");
                        valori.addLast(t.image);
          label_3:
          while (true) {
            switch (jj_nt.kind) {
            case 48:
              ;
              break;
            default:
              jj_la1[41] = jj_gen;
              break label_3;
            }
            jj_consume_token(48);
            t = jj_consume_token(number);
                        valori.addLast(t.image);
          }
          jj_consume_token(46);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
                if (valori == null) {if (true) return null;}        // no range / values

                // return range or values
                {if (true) return (String[]) valori.toArray( new String[0] );}
    throw new Error("Missing return statement in function");
  }

  final public String[] default_number() throws ParseException {
        String[] risp = null;
        Token t;
    switch (jj_nt.kind) {
    case 41:
      jj_consume_token(41);
      switch (jj_nt.kind) {
      case number:
        t = jj_consume_token(number);
                        risp = new String[2];
                        risp[0] = t.image;
                        risp[1] = null;
        break;
      case NO_DEFAULT:
        jj_consume_token(NO_DEFAULT);

        break;
      case AUTO:
        jj_consume_token(AUTO);
                        risp = new String[2];
                        risp[0] = null;
                        risp[1] = new String("auto");
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public String[] float_range() throws ParseException {
        String[] risp = null;
        Token t;
    switch (jj_nt.kind) {
    case 45:
      jj_consume_token(45);
      t = jj_consume_token(float_);
                        risp = new String[3];
                        risp[0] = new String("range");
                        risp[1] = t.image;
      jj_consume_token(47);
      t = jj_consume_token(float_);
                        risp[2] = t.image;
      jj_consume_token(46);
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public String[] default_float() throws ParseException {
        String[] risp = null;
        Token t;
    switch (jj_nt.kind) {
    case 41:
      jj_consume_token(41);
      switch (jj_nt.kind) {
      case float_:
        t = jj_consume_token(float_);
                        risp = new String[2];
                        risp[0] = t.image;
                        risp[1] = null;
        break;
      case NO_DEFAULT:
        jj_consume_token(NO_DEFAULT);

        break;
      case AUTO:
        jj_consume_token(AUTO);
                        risp = new String[2];
                        risp[0] = null;
                        risp[1] = new String("auto");
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public Element[] enumeration(Document doc) throws ParseException {
        LinkedList risp = null;
        Element tmp;
    jj_consume_token(45);
    switch (jj_nt.kind) {
    case name:
      tmp = enumerator(doc);
                                        // the first
                risp = new LinkedList();
                risp.addLast( tmp );
      label_4:
      while (true) {
        switch (jj_nt.kind) {
        case 48:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_4;
        }
        jj_consume_token(48);
        tmp = enumerator(doc);
                                        // others
                risp.addLast( tmp );
      }
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    jj_consume_token(46);
                if ( risp == null)
                        {if (true) return null;}

                {if (true) return (Element[]) risp.toArray( new Element[0] );}
    throw new Error("Missing return statement in function");
  }

  final public Element enumerator(Document doc) throws ParseException {
        Element elem = doc.createElement(IOilXMLLabels.ELEM_ENUMERATOR);
        Token t;
    t = jj_consume_token(name);
                elem.setAttribute(IOilXMLLabels.ATTR_NAME, t.image);
    impl_parameter_list(elem);
    switch (jj_nt.kind) {
    case 40:
      addDescription(elem);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
                {if (true) return elem;}
    throw new Error("Missing return statement in function");
  }

  final public void impl_parameter_list(Node elem) throws ParseException {
    switch (jj_nt.kind) {
    case 43:
      jj_consume_token(43);
      label_5:
      while (true) {
        switch (jj_nt.kind) {
        case UINT32:
        case INT32:
        case UINT64:
        case INT64:
        case FLOAT:
        case ENUM:
        case STRING:
        case BOOLEAN:
        case object_ref_type:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_5;
        }
        implementation_def(elem, true);
      }
      jj_consume_token(44);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
  }

  final public String[] default_name() throws ParseException {
        String[] risp = null;
        Token t;
    switch (jj_nt.kind) {
    case 41:
      jj_consume_token(41);
      switch (jj_nt.kind) {
      case name:
        t = jj_consume_token(name);
                        risp = new String[2];
                        risp[0] = t.image;
                        risp[1] = null;
        break;
      case NO_DEFAULT:
        jj_consume_token(NO_DEFAULT);

        break;
      case AUTO:
        jj_consume_token(AUTO);
                        risp = new String[2];
                        risp[0] = null;
                        risp[1] = new String("auto");
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public String[] default_string() throws ParseException {
        String[] risp = null;
        String s;
    switch (jj_nt.kind) {
    case 41:
      jj_consume_token(41);
      switch (jj_nt.kind) {
      case String:
        s = getString();
                        risp = new String[2];
                        risp[0] = s;
                        risp[1] = null;
        break;
      case NO_DEFAULT:
        jj_consume_token(NO_DEFAULT);

        break;
      case AUTO:
        jj_consume_token(AUTO);
                        risp = new String[2];
                        risp[0] = null;
                        risp[1] = new String("auto");
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public Element[] bool_values(Document doc) throws ParseException {
        Element[] risp = null;

        // create two Element (True and ...
        risp = new Element[2];
        risp[0] = doc.createElement(IOilXMLLabels.ELEM_ENUMERATOR);
        risp[0].setAttribute(IOilXMLLabels.ATTR_NAME, "TRUE");
        // .. and false)
        risp[1] = doc.createElement(IOilXMLLabels.ELEM_ENUMERATOR);
        risp[1].setAttribute(IOilXMLLabels.ATTR_NAME, "FALSE");
    switch (jj_nt.kind) {
    case 45:
      jj_consume_token(45);
      jj_consume_token(TRUE);
      impl_parameter_list(risp[0]);
      switch (jj_nt.kind) {
      case 40:
        addDescription(risp[0]);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(48);
      jj_consume_token(FALSE);
      impl_parameter_list(risp[1]);
      switch (jj_nt.kind) {
      case 40:
        addDescription(risp[1]);
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      jj_consume_token(46);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public String[] default_bool() throws ParseException {
        String[] risp = null;
    switch (jj_nt.kind) {
    case 41:
      jj_consume_token(41);
      switch (jj_nt.kind) {
      case TRUE:
        jj_consume_token(TRUE);
                        risp = new String[2];
                        risp[0] = "TRUE";
                        risp[1] = null;
        break;
      case FALSE:
        jj_consume_token(FALSE);
                        risp = new String[2];
                        risp[0] = "FALSE";
                        risp[1] = null;
        break;
      case NO_DEFAULT:
        jj_consume_token(NO_DEFAULT);

        break;
      case AUTO:
        jj_consume_token(AUTO);
                        risp = new String[2];
                        risp[0] = null;
                        risp[1] = new String("auto");
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
                {if (true) return risp;}
    throw new Error("Missing return statement in function");
  }

  final public void impl_ref_def(Node elem, boolean nested) throws ParseException {
        Element nodo = null;
        Token t1,t2;
    t1 = jj_consume_token(object_ref_type);

    switch (jj_nt.kind) {
    case name:
      t2 = jj_consume_token(name);
      break;
    case object:
      t2 = jj_consume_token(object);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (searchElement(elem, IOilXMLLabels.ELEM_VARIANT, IOilXMLLabels.ATTR_NAME, t2.image) != null
                        || searchElement(elem, IOilXMLLabels.ELEM_ATTRIBUTE, IOilXMLLabels.ATTR_NAME, t2.image) != null) {
                        {if (true) throw new ParseException("Found an element declared more than one time with differents proterties.\u005cn"
                        + t2.image + " declared as VARIANT/ATTRIBUTE and as " + t1.image + "\u005cn"
                        + "(row =" +t2.beginLine + ", col = "+t2.beginColumn+")");}
                }
                nodo = makeElement(elem, IOilXMLLabels.ELEM_REFERENCE, IOilXMLLabels.ATTR_NAME, t2.image);


                if (nested) {
                        setAttribute(nodo, LOCATION, "(row =" +t2.beginLine + ", col = "+t2.beginColumn+")", t2);
                }
                setAttribute(nodo, IOilXMLLabels.ATTR_OBJ_REF_TYPE, t1.image, t2);
    switch (jj_nt.kind) {
    case 45:
      jj_consume_token(45);
      jj_consume_token(46);
                setAttribute(nodo, IOilXMLLabels.ATTR_MULTIPLE_VALUES, "true", t2);
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case 40:
      addDescription(nodo);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

// ----------- Application Definition ----------------
  final public void application_definition(Document doc, Element elem) throws ParseException {
        Token t;
    jj_consume_token(CPU);
    t = jj_consume_token(name);
                elem.setAttribute(IOilXMLLabels.ATTR_NAME, t.image );
    jj_consume_token(43);
    object_definition_list(doc, elem);
    jj_consume_token(44);
    switch (jj_nt.kind) {
    case 40:
      addDescription(elem);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

  final public void object_definition_list(Document doc, Element elem) throws ParseException {
    label_6:
    while (true) {
      switch (jj_nt.kind) {
      case object:
        ;
        break;
      default:
        jj_la1[67] = jj_gen;
        break label_6;
      }
      object_definition(doc, elem);
    }
  }

  final public void object_definition(Document doc, Node elem) throws ParseException {
        Token t;
        Element nodo = doc.createElement(IOilXMLLabels.ELEM_OBJECT);
        elem.appendChild(nodo);
    t = jj_consume_token(object);
                nodo.setAttribute(IOilXMLLabels.ATTR_TYPE, t.image );
    t = jj_consume_token(name);
                nodo.setAttribute(IOilXMLLabels.ATTR_NAME, t.image );
    switch (jj_nt.kind) {
    case 43:
      jj_consume_token(43);
      parameter_list(doc, nodo);
      jj_consume_token(44);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case 40:
      addDescription(nodo);
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

  final public void parameter_list(Document doc, Node elem) throws ParseException {
    label_7:
    while (true) {
      switch (jj_nt.kind) {
      case object:
      case name:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_7;
      }
      parameter(doc, elem);
    }
  }

  final public void parameter(Document doc, Node elem) throws ParseException {
        Token t;
        Element nodo = doc.createElement(IOilXMLLabels.ELEM_PARAMETER);
        elem.appendChild(nodo);
    switch (jj_nt.kind) {
    case name:
      t = jj_consume_token(name);
      break;
    case object:
      t = jj_consume_token(object);
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                nodo.setAttribute(IOilXMLLabels.ATTR_NAME, t.image );
    jj_consume_token(41);
    attribute_value(doc, nodo);
    switch (jj_nt.kind) {
    case 40:
      addDescription(nodo);
      break;
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

  final public void attribute_value(Document doc, Element elem) throws ParseException {
        Token t;
        String s;
        Element nodo;
    switch (jj_nt.kind) {
    case name:
      t = jj_consume_token(name);
                 nodo = doc.createElement(IOilXMLLabels.ELEM_ENUM_VALUE);
                 elem.appendChild(nodo);

                nodo.setAttribute(IOilXMLLabels.ATTR_NAME, t.image );
      switch (jj_nt.kind) {
      case 43:
        jj_consume_token(43);
        parameter_list(doc, nodo);
        jj_consume_token(44);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
      break;
    case TRUE:
    case FALSE:
      switch (jj_nt.kind) {
      case TRUE:
        t = jj_consume_token(TRUE);
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                nodo = doc.createElement(IOilXMLLabels.ELEM_ENUM_VALUE);
                elem.appendChild(nodo);

                nodo.setAttribute(IOilXMLLabels.ATTR_NAME, t.image );
      switch (jj_nt.kind) {
      case 43:
        jj_consume_token(43);
        parameter_list(doc, nodo);
        jj_consume_token(44);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
      break;
    case number:
      t = jj_consume_token(number);
                elem.setAttribute(IOilXMLLabels.ATTR_CURR_VALUE, t.image );
      break;
    case float_:
      t = jj_consume_token(float_);
                elem.setAttribute(IOilXMLLabels.ATTR_CURR_VALUE, t.image );
      break;
    case String:
      s = getString();
                elem.setAttribute(IOilXMLLabels.ATTR_CURR_VALUE, s );
      break;
    case AUTO:
      t = jj_consume_token(AUTO);
                elem.setAttribute(IOilXMLLabels.ATTR_AUTO, "true" );
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void addDescription(Element elem) throws ParseException {
        String descr;
    descr = getDescription();
                Element nDescr = elem.getOwnerDocument().createElement(IOilXMLLabels.ELEM_DESCRIPTION);
                nDescr.appendChild( elem.getOwnerDocument().createTextNode( descr ) );
                elem.appendChild(nDescr);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_3_1() {
    if (jj_scan_token(45)) return true;
    if (jj_scan_token(number)) return true;
    if (jj_scan_token(47)) return true;
    if (jj_scan_token(number)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public OilParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[77];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x200000,0x800000,0x0,0x2000000,0x0,0x407f800,0x0,0x407f800,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x1000000,0x12000000,0x0,0x0,0x7f800,0x0,0x0,0x0,0x20180000,0x0,0x0,0x40180000,0x0,0x0,0x10000000,0x0,0x407f800,0x0,0x10180000,0x0,0x8180000,0x0,0x0,0x0,0x0,0x180600,0x0,0x12000000,0x0,0x0,0x0,0x2000000,0x0,0x0,0x12000000,0x12000000,0x0,0x0,0x600,0x0,0x78080600,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x100,0x0,0x100,0x0,0x100,0x0,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x0,0x2000,0x100,0x0,0x10000,0x2000,0x2000,0x0,0x200,0x2000,0x0,0x200,0x10000,0x0,0x100,0x0,0x800,0x0,0x200,0x0,0x200,0x100,0x100,0x2000,0x0,0x200,0x0,0x2000,0x100,0x100,0x0,0x800,0x100,0x0,0x0,0x100,0x800,0x0,0x800,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public OilParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public OilParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OilParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public OilParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OilParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public OilParser(OilParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(OilParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[49];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 77; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 49; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
